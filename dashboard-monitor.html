<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Spring Boot Lightweight Monitor</title>
	<style>
		body {
			font-family: 'Segoe UI', Arial, sans-serif;
			margin: 0;
			padding: 20px;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			min-height: 100vh;
			color: white;
		}
		.container {
			max-width: 1200px;
			margin: 0 auto;
		}
		h1 {
			text-align: center;
			margin-bottom: 30px;
			font-size: 2.5em;
			text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
		}
		.config {
			background: rgba(255,255,255,0.1);
			padding: 20px;
			border-radius: 10px;
			margin-bottom: 20px;
			backdrop-filter: blur(10px);
			display: flex;
			align-items: center;
			flex-wrap: wrap;
			gap: 15px;
		}
		.metrics-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			gap: 20px;
			margin-bottom: 30px;
		}
		.metric-card {
			background: rgba(255,255,255,0.15);
			padding: 25px;
			border-radius: 15px;
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255,255,255,0.2);
			transition: transform 0.3s ease;
		}
		.metric-card:hover {
			transform: translateY(-5px);
		}
		.metric-title {
			font-size: 1.2em;
			margin-bottom: 15px;
			color: #fff;
			border-bottom: 2px solid rgba(255,255,255,0.3);
			padding-bottom: 10px;
		}
		.metric-value {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 10px;
		}
		.metric-unit {
			font-size: 0.9em;
			opacity: 0.8;
		}
		.controls {
			text-align: center;
			margin-bottom: 20px;
		}
		button {
			background: rgba(255,255,255,0.2);
			color: white;
			border: none;
			padding: 12px 24px;
			border-radius: 25px;
			cursor: pointer;
			margin: 0 10px;
			font-size: 1em;
			transition: background 0.3s ease;
			border: 1px solid rgba(255,255,255,0.3);
		}
		button:hover {
			background: rgba(255,255,255,0.3);
		}
		button.active {
			background: rgba(255,255,255,0.4);
		}
		input {
			padding: 10px;
			border-radius: 5px;
			border: 1px solid rgba(255,255,255,0.3);
			background: rgba(255,255,255,0.1);
			color: white;
			margin: 0 10px;
		}
		input::placeholder {
			color: rgba(255,255,255,0.7);
		}
		.status {
			text-align: center;
			padding: 8px 12px;
			border-radius: 5px;
			flex: 1;
			min-width: 200px;
			font-size: 0.9em;
		}
		.status.success {
			background: rgba(76, 175, 80, 0.3);
		}
		.status.error {
			background: rgba(244, 67, 54, 0.3);
		}
		.progress-bar {
			width: 100%;
			height: 20px;
			background: rgba(255,255,255,0.2);
			border-radius: 10px;
			overflow: hidden;
			margin-top: 10px;
		}
		.progress-fill {
			height: 100%;
			background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
			transition: width 0.3s ease;
		}

		/* Tabs Styles */
		.tabs {
			display: flex;
			justify-content: center;
			margin-bottom: 30px;
			background: rgba(255,255,255,0.1);
			border-radius: 25px;
			padding: 5px;
			backdrop-filter: blur(10px);
		}

		.tab-button {
			background: transparent;
			color: white;
			border: none;
			padding: 15px 30px;
			border-radius: 20px;
			cursor: pointer;
			font-size: 1.1em;
			transition: all 0.3s ease;
			margin: 0 5px;
		}

		.tab-button:hover {
			background: rgba(255,255,255,0.2);
		}

		.tab-button.active {
			background: rgba(255,255,255,0.3);
			box-shadow: 0 4px 15px rgba(0,0,0,0.2);
		}

		.tab-content {
			display: none;
			animation: fadeIn 0.3s ease-in-out;
		}

		.tab-content.active {
			display: block;
		}

		@keyframes fadeIn {
			from { opacity: 0; transform: translateY(10px); }
			to { opacity: 1; transform: translateY(0); }
		}

		/* Inner Tabs Styles */
		.inner-tabs {
			display: flex;
			justify-content: center;
			margin: 0 0 20px 0;
			background: rgba(255,255,255,0.05);
			border-radius: 15px;
			padding: 5px;
		}

		.inner-tab-button {
			background: transparent;
			color: white;
			border: none;
			padding: 10px 20px;
			border-radius: 12px;
			cursor: pointer;
			font-size: 1em;
			transition: all 0.3s ease;
			margin: 0 5px;
		}

		.inner-tab-button:hover {
			background: rgba(255,255,255,0.1);
		}

		.inner-tab-button.active {
			background: rgba(255,255,255,0.2);
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
		}

		.inner-tab-content {
			display: none;
			padding: 20px;
			background: rgba(255,255,255,0.05);
			border-radius: 15px;
			margin-top: 20px;
		}

		.inner-tab-content.active {
			display: block;
			animation: fadeIn 0.3s ease-in-out;
		}

		.coming-soon {
			text-align: center;
			padding: 40px;
			color: #FFD700;
			font-size: 1.5em;
			background: rgba(255,255,255,0.1);
			border-radius: 15px;
			margin: 20px 0;
			border: 2px dashed rgba(255,255,255,0.2);
		}

		/* Memory Metrics Styles */
		.memory-metrics {
			padding: 25px 20px;
		}

		.metric-section {
			background: rgba(255,255,255,0.1);
			border-radius: 15px;
			padding: 20px;
			margin-bottom: 35px;
		}

		.metric-section h3 {
			color: #FFD700;
			margin-bottom: 20px;
			font-size: 1.3em;
			border-bottom: 1px solid rgba(255,255,255,0.2);
			padding-bottom: 10px;
		}

		.memory-metric-card {
			background: rgba(255,255,255,0.15);
			padding: 15px;
			border-radius: 10px;
			margin-bottom: 15px;
			backdrop-filter: blur(5px);
		}

		.memory-metric-card .metric-header {
			color: #fff;
			font-size: 1.1em;
			margin-bottom: 10px;
		}

		.memory-metric-card .metric-value {
			font-size: 1.8em;
			font-weight: bold;
			color: #7DCEA0;  /* Softer green */
			margin-bottom: 5px;
			font-variant-numeric: tabular-nums; /* Numbers alinhados */
			letter-spacing: 0.5px;
		}

		.memory-metric-card.warning .metric-value {
			color: #F4D03F;  /* Softer yellow */
		}

		.memory-metric-card.danger .metric-value {
			color: #F5B041;  /* Softer orange */
		}

		.historical-values {
			font-size: 0.9em;
			color: rgba(255,255,255,0.8);
			margin-top: 8px;
		}

		.historical-values span {
			display: inline-block;
			margin-right: 15px;
			padding: 4px 10px;
			border-radius: 12px;
			background: rgba(255,255,255,0.15);
			border: 1px solid rgba(255,255,255,0.1);
			transition: all 0.2s ease;
		}

		.historical-values span:hover {
			background: rgba(255,255,255,0.25);
			transform: scale(1.05);
		}

		.historical-values .up {
			color: #F5B041;  /* Slightly stronger orange */
			background: rgba(244, 67, 54, 0.2);  /* Slightly stronger red background */
			font-weight: 500;
		}

		.historical-values .down {
			color: #82E0AA;  /* Brighter, more vibrant green */
			background: rgba(76, 175, 80, 0.2);  /* Slightly stronger green background */
			font-weight: 500;
		}

		.historical-values .unchanged {
			color: #FFFFFF;  /* White color for no change */
			background: rgba(255, 255, 255, 0.1);  /* Neutral white background */
			font-weight: 400;  /* Normal weight */
			opacity: 0.8;  /* Slightly transparent to indicate neutral state */
		}

		.memory-notifications {
			margin: 20px 0;
		}

		.notification {
			background: rgba(255,255,255,0.1);
			padding: 15px;
			border-radius: 10px;
			margin-bottom: 10px;
			display: flex;
			align-items: center;
			transition: all 0.3s ease;
			cursor: pointer;
		}

		.notification:hover {
			background: rgba(255,255,255,0.15);
			transform: translateX(5px);
		}

		.notification .icon {
			font-size: 1.5em;
			margin-right: 15px;
		}

		.notification.info {
			border-left: 4px solid #2196F3;
		}

		.notification.warning {
			border-left: 4px solid #FFC107;
		}

		.memory-footer {
			margin-top: 30px;
			padding: 15px;
			background: rgba(0,0,0,0.2);
			border-radius: 10px;
		}

		.memory-footer .note {
			color: rgba(255,255,255,0.7);
			font-size: 0.9em;
			margin: 0;
		}

		/* Metric Grid Layout */
		.metric-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
			gap: 15px;
		}

		.metric-section.aggregated {
			border: 1px solid rgba(255,255,255,0.2);
			background: rgba(255,255,255,0.15);
		}

		/* Calculated Values Style */
		.memory-metric-card.calculated {
			border-left: 3px solid #2196F3;
		}

		.memory-metric-card.calculated.warning {
			border-left: 3px solid #FFC107;
		}

		/* Memory Progress Bars */
		.memory-progress-bar {
			width: 100%;
			height: 8px;
			background: rgba(255,255,255,0.2);
			border-radius: 4px;
			overflow: hidden;
			margin: 8px 0;
		}

		.memory-progress-fill {
			height: 100%;
			transition: width 0.3s ease;
			border-radius: 4px;
		}

		.memory-progress-fill.normal {
			background: linear-gradient(90deg, #4CAF50, #8BC34A);
		}

		.memory-progress-fill.warning {
			background: linear-gradient(90deg, #FFC107, #FF9800);
		}

		.memory-progress-fill.critical {
			background: linear-gradient(90deg, #FF5722, #F44336);
		}

		/* Memory Usage Percentage */
		.memory-usage-percentage {
			font-size: 0.9em;
			color: rgba(255,255,255,0.8);
			margin: 5px 0;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.usage-indicator {
			font-weight: bold;
			padding: 2px 8px;
			border-radius: 12px;
			font-size: 0.8em;
		}

		.usage-indicator.normal {
			background: rgba(76, 175, 80, 0.2);
			color: #81C784;
		}

		.usage-indicator.warning {
			background: rgba(255, 193, 7, 0.2);
			color: #FFD54F;
		}

		.usage-indicator.critical {
			background: rgba(244, 67, 54, 0.2);
			color: #E57373;
		}
	</style>
</head>
<body>
<div class="container">
	<h1>üöÄ Spring Boot Memory Monitor</h1>
	<h2 style="text-align: center; color: #4CAF50; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); margin-bottom: 30px;">
		üîí 100% Client-Side & Data-Safe: No Storage, No Servers, Pure HTML/JS
	</h2>

	<!-- Controls -->
	<div class="controls config">
		<button id="refreshBtn" onclick="refreshMetrics()">üîÑ Refresh All</button>
		<button id="autoRefreshBtn" onclick="toggleAutoRefresh()">‚è∞ Auto Refresh (OFF)</button>
		<span>Interval: </span>
		<input type="number" id="interval" value="10" min="1" max="60" style="width: 60px"> seconds
		<span id="countdownDisplay" style="margin-left: 15px; color: #FFD700; font-weight: bold;"></span>
	</div>

	<!-- Tabs -->
	<div class="tabs">
		<button class="tab-button active" onclick="switchTab('overview')">üìà Overview</button>
		<button class="tab-button" onclick="switchTab('allMetrics')">üìä All Metrics</button>
		<button class="tab-button" onclick="switchTab('info')">‚ÑπÔ∏è Information</button>
	</div>

	<!-- Configuration -->
	<div class="config" id="panel-config">
		<label>Actuator URL:</label>
		<input type="text" id="baseUrl" value="http://localhost:8081" placeholder="http://localhost:8081">
		<button onclick="updateBaseUrl()">Connect</button>
		<!-- Status -->
		<div id="status" class="status"></div>
	</div>

	<!-- Tab Content -->
	<div id="overviewTab" class="tab-content active">
		<div class="metrics-grid" id="metricsGrid">
			<!-- Metrics will be populated here -->
		</div>
	</div>

	<div id="allMetricsTab" class="tab-content">
		<div class="metrics-list" id="allMetricsList">
			<div class="inner-tabs">
				<button class="inner-tab-button active" onclick="switchInnerTab('memory')">üß† Memory</button>
				<button class="inner-tab-button" onclick="switchInnerTab('cpu')">‚ö° CPU</button>
			</div>

			<div id="memoryMetricsTab" class="inner-tab-content active">
				<div class="memory-metrics">
					<div class="metric-section aggregated">
						<h3>üîç Aggregated (All Areas)</h3>
						<div class="section-note">
							<p style="margin: 0 0 15px 0; padding: 10px; background: rgba(255,215,0,0.1); border-radius: 8px; font-size: 0.9em; color: rgba(255,255,255,0.8);">
								üí° <strong>Note:</strong> These values combine both heap and non-heap memory areas for a complete JVM memory overview.
							</p>
						</div>
						<div class="metric-grid">
							<div class="memory-metric-card">
								<div class="metric-header">Max Memory (All)</div>
								<div class="metric-value">7408.0 MB</div>
								<div class="historical-values">
									<span class="down">7390.5 MB ‚ñº 30s</span>
									<span class="up">7420.2 MB ‚ñ≤ 60s</span>
									<span class="down">7380.8 MB ‚ñº 5min</span>
									<span>7408.0 MB start</span>
								</div>
							</div>
							<div class="memory-metric-card">
								<div class="metric-header">Committed Memory (All)</div>
								<div class="metric-value">2061.3 MB</div>
								<div class="memory-usage-percentage">
									<span>27.8% of max</span>
									<span class="usage-indicator normal">NORMAL</span>
								</div>
								<div class="memory-progress-bar">
									<div class="memory-progress-fill normal" style="width: 27.8%"></div>
								</div>
								<div class="historical-values">
									<span class="down">2058.7 MB ‚ñº 30s</span>
									<span class="up">2065.1 MB ‚ñ≤ 60s</span>
									<span>2061.3 MB 5min</span>
									<span>2000.0 MB start</span>
								</div>
							</div>
							<div class="memory-metric-card">
								<div class="metric-header">Used Memory (All)</div>
								<div class="metric-value">1012.1 MB</div>
								<div class="memory-usage-percentage">
									<span>13.7% of max</span>
									<span class="usage-indicator normal">NORMAL</span>
								</div>
								<div class="memory-progress-bar">
									<div class="memory-progress-fill normal" style="width: 13.7%"></div>
								</div>
								<div class="historical-values">
									<span class="up">1015.8 MB ‚ñ≤ 30s</span>
									<span class="down">1008.3 MB ‚ñº 60s</span>
									<span class="up">1020.5 MB ‚ñ≤ 5min</span>
									<span>800.0 MB start</span>
								</div>
							</div>
							<div class="memory-metric-card calculated">
								<div class="metric-header">Free (Committed - Used)</div>
								<div class="metric-value">1049.2 MB</div>
							</div>
							<div class="memory-metric-card calculated">
								<div class="metric-header">Free Not Committed</div>
								<div class="metric-value">5346.7 MB</div>
							</div>
							<div class="memory-metric-card calculated warning">
								<div class="metric-header" title="Mem√≥ria m√°xima que pode ser alocada antes de OutOfMemoryError">To OutOfMemoryError</div>
								<div class="metric-value">6395.9 MB</div>
							</div>
						</div>
					</div>

					<div class="metric-section heap">
						<h3>üì¶ Heap Area</h3>
						<div class="section-note">
							<p style="margin: 0 0 15px 0; padding: 10px; background: rgba(76,175,80,0.1); border-radius: 8px; font-size: 0.9em; color: rgba(255,255,255,0.8);">
								üéØ <strong>Note:</strong> Heap values directly correspond to your JVM -Xmx setting. This is where your application objects live.
							</p>
						</div>
						<div class="metric-grid">
							<div class="memory-metric-card">
								<div class="metric-header">Max Memory (Heap)</div>
								<div class="metric-value">6144.0 MB</div>
								<div class="historical-values">
									<span>6144.0 MB (constant)</span>
								</div>
							</div>
							<div class="memory-metric-card">
								<div class="metric-header">Committed Memory (Heap)</div>
								<div class="metric-value">1756.0 MB</div>
								<div class="memory-usage-percentage">
									<span>28.6% of heap max</span>
									<span class="usage-indicator normal">NORMAL</span>
								</div>
								<div class="memory-progress-bar">
									<div class="memory-progress-fill normal" style="width: 28.6%"></div>
								</div>
								<div class="historical-values">
									<span class="down">1750.2 MB ‚ñº 30s</span>
									<span class="up">1760.5 MB ‚ñ≤ 60s</span>
									<span>1756.0 MB 5min</span>
								</div>
							</div>
							<div class="memory-metric-card">
								<div class="metric-header">Used Memory (Heap)</div>
								<div class="metric-value">725.8 MB</div>
								<div class="memory-usage-percentage">
									<span>11.8% of heap max</span>
									<span class="usage-indicator normal">NORMAL</span>
								</div>
								<div class="memory-progress-bar">
									<div class="memory-progress-fill normal" style="width: 11.8%"></div>
								</div>
								<div class="historical-values">
									<span class="up">730.2 MB ‚ñ≤ 30s</span>
									<span class="down">720.5 MB ‚ñº 60s</span>
									<span class="up">740.0 MB ‚ñ≤ 5min</span>
								</div>
							</div>
							<div class="memory-metric-card calculated">
								<div class="metric-header">Free (Committed - Used)</div>
								<div class="metric-value">1030.2 MB</div>
							</div>
							<div class="memory-metric-card calculated">
								<div class="metric-header">Free Not Committed</div>
								<div class="metric-value">4388.0 MB</div>
							</div>
							<div class="memory-metric-card calculated warning">
								<div class="metric-header" title="Mem√≥ria m√°xima que pode ser alocada no heap antes de OutOfMemoryError">To OutOfMemoryError</div>
								<div class="metric-value">5418.2 MB</div>
							</div>
						</div>

						<div class="memory-notifications">
							<div class="notification info">
								<span class="icon">üß†</span>
								<span class="message">The application is using about 725.8 MB of heap memory, with 1756.0 MB committed, and a maximum heap limit of 6144.0 MB.</span>
							</div>
							<div class="notification warning">
								<span class="icon">‚ö†Ô∏è</span>
								<span class="message">It can still allocate up to 5418.2 MB of heap before hitting an OutOfMemoryError.</span>
							</div>
						</div>
					</div>

					<div class="metric-section nonheap">
						<h3>üß∞ Non-Heap Area</h3>
						<div class="section-note">
							<p style="margin: 0 0 15px 0; padding: 10px; background: rgba(244,67,54,0.1); border-radius: 8px; font-size: 0.9em; color: rgba(255,255,255,0.8);">
								üîß <strong>Note:</strong> Non-heap includes Metaspace (class metadata), CodeCache (compiled code), and other JVM internal structures.
							</p>
						</div>
						<div class="metric-grid">
							<div class="memory-metric-card">
								<div class="metric-header">Max Memory (Non-Heap)</div>
								<div class="metric-value">1264.0 MB</div>
							</div>
							<div class="memory-metric-card">
								<div class="metric-header">Committed Memory (Non-Heap)</div>
								<div class="metric-value">305.3 MB</div>
								<div class="memory-usage-percentage">
									<span>24.2% of non-heap max</span>
									<span class="usage-indicator normal">NORMAL</span>
								</div>
								<div class="memory-progress-bar">
									<div class="memory-progress-fill normal" style="width: 24.2%"></div>
								</div>
								<div class="historical-values">
									<span class="up">308.5 MB ‚ñ≤ 30s</span>
									<span class="up">310.2 MB ‚ñ≤ 60s</span>
									<span class="up">315.0 MB ‚ñ≤ 5min</span>
								</div>
							</div>
							<div class="memory-metric-card">
								<div class="metric-header">Used Memory (Non-Heap)</div>
								<div class="metric-value">286.4 MB</div>
								<div class="memory-usage-percentage">
									<span>22.7% of non-heap max</span>
									<span class="usage-indicator normal">NORMAL</span>
								</div>
								<div class="memory-progress-bar">
									<div class="memory-progress-fill normal" style="width: 22.7%"></div>
								</div>
								<div class="historical-values">
									<span class="up">288.7 MB ‚ñ≤ 30s</span>
									<span class="up">290.1 MB ‚ñ≤ 60s</span>
									<span class="up">295.0 MB ‚ñ≤ 5min</span>
								</div>
							</div>
							<div class="memory-metric-card calculated">
								<div class="metric-header">Free (Committed - Used)</div>
								<div class="metric-value">18.9 MB</div>
							</div>
							<div class="memory-metric-card calculated">
								<div class="metric-header">Free Not Committed</div>
								<div class="metric-value">958.7 MB</div>
							</div>
							<div class="memory-metric-card calculated warning">
								<div class="metric-header" title="Mem√≥ria m√°xima que pode ser alocada no non-heap antes de OutOfMemoryError">To OutOfMemoryError</div>
								<div class="metric-value">977.6 MB</div>
							</div>
						</div>
					</div>


				</div>
			</div>

			<div id="cpuMetricsTab" class="inner-tab-content">
				<div class="coming-soon">
					üöß Coming Soon: CPU Performance Analytics üöß
					<p style="font-size: 0.8em; margin-top: 10px; color: rgba(255,255,255,0.8);">
						Detailed CPU metrics and performance insights are on the way!
					</p>
				</div>
			</div>
		</div>
	</div>

	<div id="infoTab" class="tab-content">
		<div class="info-sections">
			<div class="info-section">
				<h2>üß† Memory Metrics</h2>
				<div class="info-card">
					<h3>Heap Memory Used</h3>
					<p><strong>What it is:</strong> Amount of heap memory currently in use by the JVM.</p>
					<p><strong>Why it matters:</strong> Indicates how much of the available memory is consumed by application objects.</p>
					<p><strong>‚ö†Ô∏è Alert:</strong> If constantly > 80% of max, may indicate memory leak or need for more memory.</p>
					<p><strong>‚úÖ Ideal:</strong> Between 40-70% of heap max during normal operation.</p>
				</div>
				<div class="info-card">
					<h3>Heap Memory Max</h3>
					<p><strong>What it is:</strong> Maximum amount of heap memory the JVM can use (defined by -Xmx).</p>
					<p><strong>Why it matters:</strong> Defines the upper limit for object allocation.</p>
					<p><strong>‚ö†Ô∏è Alert:</strong> If too low, may cause OutOfMemoryError. If too high, may impact GC.</p>
					<p><strong>‚úÖ Ideal:</strong> Configure based on application profile and available resources.</p>
				</div>
				<div class="info-card">
					<h3>Non-Heap Memory Used</h3>
					<p><strong>What it is:</strong> Memory used outside the heap (Metaspace, Code Cache, etc.).</p>
					<p><strong>Why it matters:</strong> Includes compiled bytecode, class metadata, etc.</p>
					<p><strong>‚ö†Ô∏è Alert:</strong> Constant growth may indicate excessive class loading.</p>
					<p><strong>‚úÖ Ideal:</strong> Stable after application warmup.</p>
				</div>
			</div>
			<div class="info-section">
				<h2>‚ö° Performance Metrics</h2>
				<div class="info-card">
					<h3>CPU Usage</h3>
					<p><strong>What it is:</strong> System CPU usage percentage.</p>
					<p><strong>Why it matters:</strong> Indicates overall computational load of the system.</p>
					<p><strong>‚ö†Ô∏è Alert:</strong> Constantly > 80% may indicate CPU bottleneck.</p>
					<p><strong>‚úÖ Ideal:</strong> < 70% in normal operation, allowing occasional spikes.</p>
				</div>
				<div class="info-card">
					<h3>Live Threads</h3>
					<p><strong>What it is:</strong> Number of active threads in the JVM.</p>
					<p><strong>Why it matters:</strong> Too many threads can impact performance and consume memory.</p>
					<p><strong>‚ö†Ô∏è Alert:</strong> Uncontrolled growth may indicate thread leaks.</p>
					<p><strong>‚úÖ Ideal:</strong> Stable number, proportional to workload.</p>
				</div>
			</div>
			<div class="info-section">
				<h2>üóëÔ∏è Garbage Collection</h2>
				<div class="info-card">
					<h3>GC Memory Allocated</h3>
					<p><strong>What it is:</strong> Total memory allocated and subsequently collected by GC.</p>
					<p><strong>Why it matters:</strong> Indicates allocation activity and GC pressure.</p>
					<p><strong>‚ö†Ô∏è Alert:</strong> Rapid growth may indicate high allocation rate.</p>
					<p><strong>‚úÖ Ideal:</strong> Linear and predictable growth.</p>
				</div>
			</div>
			<div class="info-section">
				<h2>üéØ Optimization Tips</h2>
				<div class="info-card">
					<h3>Memory Management</h3>
					<ul>
						<li><strong>String Pooling:</strong> Use <code>StringBuilder</code> for concatenation in loops</li>
						<li><strong>Object Reuse:</strong> Implement object pooling for expensive objects</li>
						<li><strong>Lazy Loading:</strong> Load resources only when needed</li>
						<li><strong>Weak References:</strong> Use for caches that can be freed by GC</li>
					</ul>
				</div>
				<div class="info-card">
					<h3>JVM Tuning</h3>
					<ul>
						<li><strong>-Xmx:</strong> Set heap max based on application profile</li>
						<li><strong>-XX:+UseG1GC:</strong> G1GC for applications with heap > 4GB</li>
						<li><strong>-XX:MaxGCPauseMillis:</strong> Configure GC pause target</li>
						<li><strong>-XX:+HeapDumpOnOutOfMemoryError:</strong> For memory leak debugging</li>
					</ul>
				</div>

				<div class="info-card">
					<h3>Monitoring Best Practices</h3>
					<ul>
						<li>üìä <strong>Alerts:</strong> Set alerts for CPU > 80%, Memory > 85%</li>
						<li>üìà <strong>Trending:</strong> Use Prometheus + Grafana for historical analysis</li>
						<li>üîç <strong>Profiling:</strong> Use JProfiler/VisualVM for detailed analysis</li>
						<li>üìù <strong>Logs:</strong> Monitor GC logs for anomalous patterns</li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>

<footer class="footer">
	<div class="footer-section">
		<h3>Version</h3>
		<p>
			<strong>v1.3.0</strong> - Released 2025-09-24
		</p>
	</div>
	<div class="footer-section">
		<h3>About the Author</h3>
		<p>
			Developed by <a href="https://github.com/fhgomes/fhgomes" target="_blank" rel="noopener">fhgomes</a>
		</p>
	</div>
	<div class="footer-section">
		<h3>License</h3>
		<p>
			This project is licensed under the <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener">MIT License</a>.
		</p>
	</div>
	<div class="footer-section">
		<h3>Contributing</h3>
		<p>
			Contributions are welcome! See the <a href="https://github.com/fhgomes/lightweight-spring-actuator-monitor#contributing" target="_blank" rel="noopener">project page</a> for details.
		</p>
	</div>
	<div class="footer-section">
		<h3>Source Code</h3>
		<p>
			View on <a href="https://github.com/fhgomes/lightweight-spring-actuator-monitor" target="_blank" rel="noopener">GitHub</a>
		</p>
	</div>
</footer>
<style>
	.footer {
		margin-top: 40px;
		padding: 30px 0 10px 0;
		background: rgba(0,0,0,0.15);
		border-radius: 15px;
		text-align: center;
		color: #fff;
		font-size: 1em;
		box-shadow: 0 2px 8px rgba(0,0,0,0.08);
	}
	.footer-section {
		margin-bottom: 18px;
	}
	.footer-section h3 {
		margin-bottom: 8px;
		font-size: 1.1em;
		color: #FFD700;
	}
	.footer a {
		color: #FFD700;
		text-decoration: underline;
	}
	.footer a:hover {
		color: #fff;
		text-decoration: none;
	}
</style>

<script>
	let baseUrl = 'http://localhost:8081';
	let autoRefreshInterval = null;
	let isAutoRefreshOn = false;
	let memoryHistory = {};
	let countdownInterval = null;
	let countdownSeconds = 0;
	let refreshIntervalMs = 5000;

	const metrics = [
		{
			id: 'heap-used',
			endpoint: '/actuator/metrics/jvm.memory.used?tag=area:heap',
			title: 'Heap Memory Used',
			unit: 'MB',
			format: value => (value / 1024 / 1024).toFixed(2)
		},
		{
			id: 'heap-max',
			endpoint: '/actuator/metrics/jvm.memory.max?tag=area:heap',
			title: 'Heap Memory Max',
			unit: 'MB',
			format: value => (value / 1024 / 1024).toFixed(2)
		},
		{
			id: 'nonheap-used',
			endpoint: '/actuator/metrics/jvm.memory.used?tag=area:nonheap',
			title: 'Non-Heap Memory Used',
			unit: 'MB',
			format: value => (value / 1024 / 1024).toFixed(2)
		},
		{
			id: 'cpu-usage',
			endpoint: '/actuator/metrics/system.cpu.usage',
			title: 'CPU Usage',
			unit: '%',
			format: value => (value * 100).toFixed(2)
		},
		{
			id: 'gc-allocated',
			endpoint: '/actuator/metrics/jvm.gc.memory.allocated',
			title: 'GC Memory Allocated',
			unit: 'MB',
			format: value => (value / 1024 / 1024).toFixed(2)
		},
		{
			id: 'threads',
			endpoint: '/actuator/metrics/jvm.threads.live',
			title: 'Live Threads',
			unit: 'threads',
			format: value => Math.round(value)
		}
	];

	async function updateBaseUrl() {
		baseUrl = document.getElementById('baseUrl').value.replace(/\/$/, '');
		const success = await refreshMetrics();

		// Change button text to "Refresh Now" after successful connection
		if (success) {
			const connectBtn = document.querySelector('button[onclick="updateBaseUrl()"]');
			if (connectBtn) {
				connectBtn.textContent = 'üîÑ Refresh Now';
			}
		}
	}

	function createMetricCard(metric) {
		return `
                <div class="metric-card" id="card-${metric.id}">
                    <div class="metric-title">${metric.title}</div>
                    <div class="metric-value" id="value-${metric.id}">--</div>
                    <div class="metric-unit">${metric.unit}</div>
                    <div class="progress-bar" id="progress-${metric.id}" style="display: none;">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            `;
	}

	function initializeGrid() {
		const grid = document.getElementById('metricsGrid');
		grid.innerHTML = metrics.map(createMetricCard).join('');
	}

	async function fetchMetric(metric) {
		try {
			const response = await fetch(baseUrl + metric.endpoint);
			if (!response.ok) throw new Error(`HTTP ${response.status}`);

			const data = await response.json();
			const value = data.measurements?.[0]?.value;

			if (value !== undefined) {
				const formattedValue = metric.format(value);
				document.getElementById(`value-${metric.id}`).textContent = formattedValue;

				// Show progress bar for memory metrics
				if (metric.id.includes('heap') && metric.id === 'heap-used') {
					const maxMetric = metrics.find(m => m.id === 'heap-max');
					const maxResponse = await fetch(baseUrl + maxMetric.endpoint);
					if (maxResponse.ok) {
						const maxData = await maxResponse.json();
						const maxValue = maxData.measurements?.[0]?.value;
						if (maxValue) {
							const percentage = (value / maxValue) * 100;
							const progressBar = document.getElementById(`progress-${metric.id}`);
							progressBar.style.display = 'block';
							progressBar.querySelector('.progress-fill').style.width = percentage + '%';
						}
					}
				}

				return true;
			}
		} catch (error) {
			document.getElementById(`value-${metric.id}`).textContent = 'Error';
			console.error(`Error fetching ${metric.title}:`, error);
			return false;
		}
		return false;
	}

	async function refreshMetrics() {
		// Stop countdown during refresh to avoid interference
		if (countdownInterval) {
			clearInterval(countdownInterval);
			countdownInterval = null;
		}

		const status = document.getElementById('status');
		status.textContent = 'üîÑ Loading metrics...';
		status.className = 'status';

		let successCount = 0;
		const promises = metrics.map(async (metric) => {
			const success = await fetchMetric(metric);
			if (success) successCount++;
		});

		await Promise.all(promises);

		if (successCount > 0) {
			status.textContent = `‚úÖ ${successCount}/${metrics.length} metrics loaded - ${new Date().toLocaleTimeString()}`;
			status.className = 'status success';
		} else {
			status.textContent = '‚ùå Error loading metrics. Check if Actuator is enabled and accessible.';
			status.className = 'status error';
		}

		// Also refresh memory metrics if memory tab is active
		const memoryTab = document.getElementById('memoryMetricsTab');
		if (memoryTab && memoryTab.classList.contains('active')) {
			await refreshMemoryMetrics();
		}

		// Restart countdown after manual refresh if auto-refresh is enabled
		if (isAutoRefreshOn) {
			startCountdown();
		}

		// Return success status for use by other functions
		return successCount > 0;
	}

	function updateCountdownDisplay() {
		const countdownDisplay = document.getElementById('countdownDisplay');
		if (isAutoRefreshOn && countdownSeconds > 0) {
			countdownDisplay.textContent = `‚è∞ Next refresh in... ${countdownSeconds}s`;
		} else {
			countdownDisplay.textContent = '';
		}
	}

	function startCountdown() {
		// Always stop existing countdown first to prevent duplicates
		if (countdownInterval) {
			clearInterval(countdownInterval);
			countdownInterval = null;
		}

		countdownSeconds = Math.floor(refreshIntervalMs / 1000);
		updateCountdownDisplay();

		countdownInterval = setInterval(() => {
			countdownSeconds--;
			if (countdownSeconds > 0) {
				updateCountdownDisplay();
			} else {
				clearInterval(countdownInterval);
				countdownInterval = null;
			}
		}, 1000);
	}

	function stopCountdown() {
		if (countdownInterval) {
			clearInterval(countdownInterval);
			countdownInterval = null;
		}
		countdownSeconds = 0;
		updateCountdownDisplay(); // Clear the countdown display
	}

	function stopAutoRefresh() {
		if (autoRefreshInterval) {
			clearInterval(autoRefreshInterval);
			autoRefreshInterval = null;
		}
		stopCountdown();
	}

	function startAutoRefresh() {
		// Always stop existing intervals first to prevent duplicates
		stopAutoRefresh();

		refreshIntervalMs = parseInt(document.getElementById('interval').value) * 1000;
		autoRefreshInterval = setInterval(() => {
			refreshMetrics().then(() => {
				if (isAutoRefreshOn) {
					startCountdown();
				}
			});
		}, refreshIntervalMs);

		// Do initial refresh
		refreshMetrics().then(() => {
			if (isAutoRefreshOn) {
				startCountdown();
			}
		});
	}

	function toggleAutoRefresh() {
		const btn = document.getElementById('autoRefreshBtn');

		if (isAutoRefreshOn) {
			stopAutoRefresh();
			btn.textContent = '‚è∞ Auto Refresh (OFF)';
			btn.classList.remove('active');
			isAutoRefreshOn = false;
		} else {
			btn.textContent = '‚è∞ Auto Refresh (ON)';
			btn.classList.add('active');
			isAutoRefreshOn = true;
			startAutoRefresh();
		}
	}

	// Initialize
	document.addEventListener('DOMContentLoaded', function() {
		initializeGrid();
		refreshMetrics();
	});

	// Handle Enter key in URL input
	document.getElementById('baseUrl').addEventListener('keypress', function(e) {
		if (e.key === 'Enter') {
			updateBaseUrl();
		}
	});

	// Handle interval input changes - reset countdown when user changes interval
	document.getElementById('interval').addEventListener('input', function(e) {
		const newInterval = parseInt(e.target.value);
		if (newInterval >= 1 && newInterval <= 60) {
			// If auto-refresh is enabled, restart it with the new interval
			if (isAutoRefreshOn) {
				startAutoRefresh(); // This will handle all cleanup and restart with new interval
			}
		}
	});

	// Tab functionality
	function switchTab(tabName) {
		// Remove active class from all tabs
		document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
		document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

		// Add active class to selected tab
		event.target.classList.add('active');
		document.getElementById(tabName + 'Tab').classList.add('active');
	}

	// Inner tab functionality
	function switchInnerTab(tabName) {
		// Remove active class from all inner tabs
		document.querySelectorAll('.inner-tab-button').forEach(btn => btn.classList.remove('active'));
		document.querySelectorAll('.inner-tab-content').forEach(content => content.classList.remove('active'));

		// Add active class to selected inner tab
		event.target.classList.add('active');
		document.getElementById(tabName + 'MetricsTab').classList.add('active');

		// Refresh memory metrics when memory tab is selected
		if (tabName === 'memory') {
			refreshMemoryMetrics();
		}
	}

	// Memory metrics functions
	async function fetchMemoryData() {
		try {
			const [heapUsed, heapMax, heapCommitted, nonheapUsed, nonheapMax, nonheapCommitted] = await Promise.all([
				fetch(baseUrl + '/actuator/metrics/jvm.memory.used?tag=area:heap').then(r => r.json()),
				fetch(baseUrl + '/actuator/metrics/jvm.memory.max?tag=area:heap').then(r => r.json()),
				fetch(baseUrl + '/actuator/metrics/jvm.memory.committed?tag=area:heap').then(r => r.json()),
				fetch(baseUrl + '/actuator/metrics/jvm.memory.used?tag=area:nonheap').then(r => r.json()),
				fetch(baseUrl + '/actuator/metrics/jvm.memory.max?tag=area:nonheap').then(r => r.json()),
				fetch(baseUrl + '/actuator/metrics/jvm.memory.committed?tag=area:nonheap').then(r => r.json())
			]);

			return {
				heap: {
					used: heapUsed.measurements?.[0]?.value || 0,
					max: heapMax.measurements?.[0]?.value || 0,
					committed: heapCommitted.measurements?.[0]?.value || 0
				},
				nonheap: {
					used: nonheapUsed.measurements?.[0]?.value || 0,
					max: nonheapMax.measurements?.[0]?.value || 0,
					committed: nonheapCommitted.measurements?.[0]?.value || 0
				}
			};
		} catch (error) {
			console.error('Error fetching memory data:', error);
			return null;
		}
	}

	function formatMemory(bytes) {
		return (bytes / 1024 / 1024).toFixed(1);
	}

	function updateMemoryHistory(key, value) {
		const now = Date.now();
		if (!memoryHistory[key]) {
			memoryHistory[key] = [];
		}

		memoryHistory[key].push({ value, timestamp: now });

		// Keep only last 10 values for trending
		if (memoryHistory[key].length > 10) {
			memoryHistory[key] = memoryHistory[key].slice(-10);
		}
	}

	function getTrendingHtml(key, currentValue, unit = 'MB') {
		if (!memoryHistory[key] || memoryHistory[key].length < 2) {
			return `<span>${currentValue} ${unit} (initializing)</span>`;
		}

		const history = memoryHistory[key];
		const now = Date.now();
		let html = '';

		// Get the starting value (first item in history) for all comparisons
		const startingValue = history[0].value; // Always reference the first value as "start"
		const currentHistoryItem = history[history.length - 1]; // Most recent (current)

		// Add the "start" reference first at the top
		const startFormatted = unit === 'MB' ? formatMemory(startingValue) : startingValue.toFixed(1);
		html += `<span style="display: block; margin-bottom: 8px; font-weight: bold; color: #FFD700;">${startFormatted} ${unit} start</span>`;

		// Show last 3-4 historical values with trends below (all compared to starting value)
		const recentHistory = history.slice(-4, -1); // Exclude current value

		recentHistory.forEach((item, index) => {
			const timeAgo = Math.round((now - item.timestamp) / 1000);
			const timeLabel = timeAgo < 60 ? `${timeAgo}s` : `${Math.round(timeAgo / 60)}min`;

			let trend = '';
			let trendClass = '';
			let differenceText = '';

			// Always compare each historical value against the starting value
			const difference = item.value - startingValue;
			const absDifference = Math.abs(difference);
			const formattedDifference = unit === 'MB' ? formatMemory(absDifference) : absDifference.toFixed(1);

			if (difference > 0) {
				trend = ' ‚ñ≤';
				trendClass = 'up';
				differenceText = `${formattedDifference} ${unit}${trend}`;
			} else if (difference < 0) {
				trend = ' ‚ñº';
				trendClass = 'down';
				differenceText = `${formattedDifference} ${unit}${trend}`;
			} else {
				// No change from start - show 0.0 with no arrow
				trendClass = 'unchanged';
				differenceText = `0.0 ${unit}`;
			}

			html += `<span class="${trendClass}">${differenceText} ${timeLabel}</span>`;
		});

		return html;
	}

	function updateMemoryCard(selector, value, unit, historyKey, maxValue = null, showProgress = false) {
		const card = document.querySelector(selector);
		if (!card) return;

		const formattedValue = unit === 'MB' ? formatMemory(value) : value.toFixed(1);
		const valueElement = card.querySelector('.metric-value');
		if (valueElement) {
			valueElement.textContent = `${formattedValue} ${unit}`;
		}

		// Update history and trending
		updateMemoryHistory(historyKey, value);
		const historicalElement = card.querySelector('.historical-values');
		if (historicalElement) {
			historicalElement.innerHTML = getTrendingHtml(historyKey, formattedValue, unit);
		}

		// Update progress bar if needed
		if (showProgress && maxValue && maxValue > 0) {
			const percentage = (value / maxValue) * 100;
			const progressBar = card.querySelector('.memory-progress-fill');
			const usageElement = card.querySelector('.memory-usage-percentage span:first-child');
			const indicatorElement = card.querySelector('.usage-indicator');

			if (progressBar) {
				progressBar.style.width = `${percentage.toFixed(1)}%`;

				// Update progress bar color based on percentage
				progressBar.className = 'memory-progress-fill';
				if (percentage > 80) {
					progressBar.classList.add('critical');
				} else if (percentage > 60) {
					progressBar.classList.add('warning');
				} else {
					progressBar.classList.add('normal');
				}
			}

			if (usageElement) {
				usageElement.textContent = `${percentage.toFixed(1)}% of max`;
			}

			if (indicatorElement) {
				indicatorElement.className = 'usage-indicator';
				if (percentage > 80) {
					indicatorElement.classList.add('critical');
					indicatorElement.textContent = 'CRITICAL';
				} else if (percentage > 60) {
					indicatorElement.classList.add('warning');
					indicatorElement.textContent = 'WARNING';
				} else {
					indicatorElement.classList.add('normal');
					indicatorElement.textContent = 'NORMAL';
				}
			}
		}
	}

	async function refreshMemoryMetrics() {
		const memoryData = await fetchMemoryData();
		if (!memoryData) {
			console.error('Failed to fetch memory data');
			return;
		}

		const { heap, nonheap } = memoryData;

		// Calculate aggregated values
		const totalUsed = heap.used + nonheap.used;
		const totalMax = heap.max + nonheap.max;
		const totalCommitted = heap.committed + nonheap.committed;

		// Update Aggregated section
		updateMemoryCard('.metric-section.aggregated .memory-metric-card:nth-child(1)', totalMax, 'MB', 'total-max');
		updateMemoryCard('.metric-section.aggregated .memory-metric-card:nth-child(2)', totalCommitted, 'MB', 'total-committed', totalMax, true);
		updateMemoryCard('.metric-section.aggregated .memory-metric-card:nth-child(3)', totalUsed, 'MB', 'total-used', totalMax, true);

		// Update calculated values for aggregated
		const totalFreeCommitted = totalCommitted - totalUsed;
		const totalFreeNotCommitted = totalMax - totalCommitted;
		const totalToOOM = totalMax - totalUsed;

		document.querySelector('.metric-section.aggregated .memory-metric-card:nth-child(4) .metric-value').textContent = `${formatMemory(totalFreeCommitted)} MB`;
		document.querySelector('.metric-section.aggregated .memory-metric-card:nth-child(5) .metric-value').textContent = `${formatMemory(totalFreeNotCommitted)} MB`;
		document.querySelector('.metric-section.aggregated .memory-metric-card:nth-child(6) .metric-value').textContent = `${formatMemory(totalToOOM)} MB`;

		// Update Heap section
		updateMemoryCard('.metric-section.heap .memory-metric-card:nth-child(1)', heap.max, 'MB', 'heap-max');
		updateMemoryCard('.metric-section.heap .memory-metric-card:nth-child(2)', heap.committed, 'MB', 'heap-committed', heap.max, true);
		updateMemoryCard('.metric-section.heap .memory-metric-card:nth-child(3)', heap.used, 'MB', 'heap-used', heap.max, true);

		// Update calculated values for heap
		const heapFreeCommitted = heap.committed - heap.used;
		const heapFreeNotCommitted = heap.max - heap.committed;
		const heapToOOM = heap.max - heap.used;

		document.querySelector('.metric-section.heap .memory-metric-card:nth-child(4) .metric-value').textContent = `${formatMemory(heapFreeCommitted)} MB`;
		document.querySelector('.metric-section.heap .memory-metric-card:nth-child(5) .metric-value').textContent = `${formatMemory(heapFreeNotCommitted)} MB`;
		document.querySelector('.metric-section.heap .memory-metric-card:nth-child(6) .metric-value').textContent = `${formatMemory(heapToOOM)} MB`;

		// Update Non-heap section
		updateMemoryCard('.metric-section.nonheap .memory-metric-card:nth-child(1)', nonheap.max, 'MB', 'nonheap-max');
		updateMemoryCard('.metric-section.nonheap .memory-metric-card:nth-child(2)', nonheap.committed, 'MB', 'nonheap-committed', nonheap.max, true);
		updateMemoryCard('.metric-section.nonheap .memory-metric-card:nth-child(3)', nonheap.used, 'MB', 'nonheap-used', nonheap.max, true);

		// Update calculated values for non-heap
		const nonheapFreeCommitted = nonheap.committed - nonheap.used;
		const nonheapFreeNotCommitted = nonheap.max - nonheap.committed;
		const nonheapToOOM = nonheap.max - nonheap.used;

		document.querySelector('.metric-section.nonheap .memory-metric-card:nth-child(4) .metric-value').textContent = `${formatMemory(nonheapFreeCommitted)} MB`;
		document.querySelector('.metric-section.nonheap .memory-metric-card:nth-child(5) .metric-value').textContent = `${formatMemory(nonheapFreeNotCommitted)} MB`;
		document.querySelector('.metric-section.nonheap .memory-metric-card:nth-child(6) .metric-value').textContent = `${formatMemory(nonheapToOOM)} MB`;

		// Update notifications
		const heapUsedMB = formatMemory(heap.used);
		const heapCommittedMB = formatMemory(heap.committed);
		const heapMaxMB = formatMemory(heap.max);
		const heapToOOMMB = formatMemory(heapToOOM);

		document.querySelector('.memory-notifications .notification.info .message').textContent =
			`The application is using about ${heapUsedMB} MB of heap memory, with ${heapCommittedMB} MB committed, and a maximum heap limit of ${heapMaxMB} MB.`;

		document.querySelector('.memory-notifications .notification.warning .message').textContent =
			`It can still allocate up to ${heapToOOMMB} MB of heap before hitting an OutOfMemoryError.`;

		console.log('Memory metrics updated with real data');
	}
</script>
</body>
</html>
